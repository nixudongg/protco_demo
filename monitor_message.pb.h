// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: monitor_message.proto

#ifndef PROTOBUF_monitor_5fmessage_2eproto__INCLUDED
#define PROTOBUF_monitor_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class CommandHead;
class CommandHeadDefaultTypeInternal;
extern CommandHeadDefaultTypeInternal _CommandHead_default_instance_;
class CurrentResourceUsage;
class CurrentResourceUsageDefaultTypeInternal;
extern CurrentResourceUsageDefaultTypeInternal _CurrentResourceUsage_default_instance_;
class DeviceInfo;
class DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class ScadaServiceStatus;
class ScadaServiceStatusDefaultTypeInternal;
extern ScadaServiceStatusDefaultTypeInternal _ScadaServiceStatus_default_instance_;
class ScadaVersion;
class ScadaVersionDefaultTypeInternal;
extern ScadaVersionDefaultTypeInternal _ScadaVersion_default_instance_;
class SyncFileInfo;
class SyncFileInfoDefaultTypeInternal;
extern SyncFileInfoDefaultTypeInternal _SyncFileInfo_default_instance_;
class SyncFileInfoList;
class SyncFileInfoListDefaultTypeInternal;
extern SyncFileInfoListDefaultTypeInternal _SyncFileInfoList_default_instance_;

namespace protobuf_monitor_5fmessage_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_monitor_5fmessage_2eproto

enum ServiceStatus {
  STOPPING = 0,
  RUNNING = 1
};
bool ServiceStatus_IsValid(int value);
const ServiceStatus ServiceStatus_MIN = STOPPING;
const ServiceStatus ServiceStatus_MAX = RUNNING;
const int ServiceStatus_ARRAYSIZE = ServiceStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceStatus_descriptor();
inline const ::std::string& ServiceStatus_Name(ServiceStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceStatus_descriptor(), value);
}
inline bool ServiceStatus_Parse(
    const ::std::string& name, ServiceStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceStatus>(
    ServiceStatus_descriptor(), name, value);
}
// ===================================================================

class CommandHead : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CommandHead) */ {
 public:
  CommandHead();
  virtual ~CommandHead();

  CommandHead(const CommandHead& from);

  inline CommandHead& operator=(const CommandHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandHead& default_instance();

  static inline const CommandHead* internal_default_instance() {
    return reinterpret_cast<const CommandHead*>(
               &_CommandHead_default_instance_);
  }

  void Swap(CommandHead* other);

  // implements Message ----------------------------------------------

  inline CommandHead* New() const PROTOBUF_FINAL { return New(NULL); }

  CommandHead* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommandHead& from);
  void MergeFrom(const CommandHead& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommandHead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cmdId = 1;
  bool has_cmdid() const;
  void clear_cmdid();
  static const int kCmdIdFieldNumber = 1;
  ::google::protobuf::uint32 cmdid() const;
  void set_cmdid(::google::protobuf::uint32 value);

  // required uint32 cmdLength = 2;
  bool has_cmdlength() const;
  void clear_cmdlength();
  static const int kCmdLengthFieldNumber = 2;
  ::google::protobuf::uint32 cmdlength() const;
  void set_cmdlength(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CommandHead)
 private:
  void set_has_cmdid();
  void clear_has_cmdid();
  void set_has_cmdlength();
  void clear_has_cmdlength();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 cmdid_;
  ::google::protobuf::uint32 cmdlength_;
  friend struct  protobuf_monitor_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeviceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DeviceInfo) */ {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceInfo& default_instance();

  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }

  void Swap(DeviceInfo* other);

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DeviceInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeviceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostName = 2;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostNameFieldNumber = 2;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // required string system = 3;
  bool has_system() const;
  void clear_system();
  static const int kSystemFieldNumber = 3;
  const ::std::string& system() const;
  void set_system(const ::std::string& value);
  #if LANG_CXX11
  void set_system(::std::string&& value);
  #endif
  void set_system(const char* value);
  void set_system(const char* value, size_t size);
  ::std::string* mutable_system();
  ::std::string* release_system();
  void set_allocated_system(::std::string* system);

  // required string hardware = 4;
  bool has_hardware() const;
  void clear_hardware();
  static const int kHardwareFieldNumber = 4;
  const ::std::string& hardware() const;
  void set_hardware(const ::std::string& value);
  #if LANG_CXX11
  void set_hardware(::std::string&& value);
  #endif
  void set_hardware(const char* value);
  void set_hardware(const char* value, size_t size);
  ::std::string* mutable_hardware();
  ::std::string* release_hardware();
  void set_allocated_hardware(::std::string* hardware);

  // required string nodeName = 5;
  bool has_nodename() const;
  void clear_nodename();
  static const int kNodeNameFieldNumber = 5;
  const ::std::string& nodename() const;
  void set_nodename(const ::std::string& value);
  #if LANG_CXX11
  void set_nodename(::std::string&& value);
  #endif
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  ::std::string* mutable_nodename();
  ::std::string* release_nodename();
  void set_allocated_nodename(::std::string* nodename);

  // required string version = 6;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 6;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // required string memorySize = 7;
  bool has_memorysize() const;
  void clear_memorysize();
  static const int kMemorySizeFieldNumber = 7;
  const ::std::string& memorysize() const;
  void set_memorysize(const ::std::string& value);
  #if LANG_CXX11
  void set_memorysize(::std::string&& value);
  #endif
  void set_memorysize(const char* value);
  void set_memorysize(const char* value, size_t size);
  ::std::string* mutable_memorysize();
  ::std::string* release_memorysize();
  void set_allocated_memorysize(::std::string* memorysize);

  // required string harddiskSize = 8;
  bool has_harddisksize() const;
  void clear_harddisksize();
  static const int kHarddiskSizeFieldNumber = 8;
  const ::std::string& harddisksize() const;
  void set_harddisksize(const ::std::string& value);
  #if LANG_CXX11
  void set_harddisksize(::std::string&& value);
  #endif
  void set_harddisksize(const char* value);
  void set_harddisksize(const char* value, size_t size);
  ::std::string* mutable_harddisksize();
  ::std::string* release_harddisksize();
  void set_allocated_harddisksize(::std::string* harddisksize);

  // required .CommandHead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::CommandHead& head() const;
  ::CommandHead* mutable_head();
  ::CommandHead* release_head();
  void set_allocated_head(::CommandHead* head);

  // @@protoc_insertion_point(class_scope:DeviceInfo)
 private:
  void set_has_head();
  void clear_has_head();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_system();
  void clear_has_system();
  void set_has_hardware();
  void clear_has_hardware();
  void set_has_nodename();
  void clear_has_nodename();
  void set_has_version();
  void clear_has_version();
  void set_has_memorysize();
  void clear_has_memorysize();
  void set_has_harddisksize();
  void clear_has_harddisksize();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr system_;
  ::google::protobuf::internal::ArenaStringPtr hardware_;
  ::google::protobuf::internal::ArenaStringPtr nodename_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr memorysize_;
  ::google::protobuf::internal::ArenaStringPtr harddisksize_;
  ::CommandHead* head_;
  friend struct  protobuf_monitor_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CurrentResourceUsage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CurrentResourceUsage) */ {
 public:
  CurrentResourceUsage();
  virtual ~CurrentResourceUsage();

  CurrentResourceUsage(const CurrentResourceUsage& from);

  inline CurrentResourceUsage& operator=(const CurrentResourceUsage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentResourceUsage& default_instance();

  static inline const CurrentResourceUsage* internal_default_instance() {
    return reinterpret_cast<const CurrentResourceUsage*>(
               &_CurrentResourceUsage_default_instance_);
  }

  void Swap(CurrentResourceUsage* other);

  // implements Message ----------------------------------------------

  inline CurrentResourceUsage* New() const PROTOBUF_FINAL { return New(NULL); }

  CurrentResourceUsage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CurrentResourceUsage& from);
  void MergeFrom(const CurrentResourceUsage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CurrentResourceUsage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CommandHead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::CommandHead& head() const;
  ::CommandHead* mutable_head();
  ::CommandHead* release_head();
  void set_allocated_head(::CommandHead* head);

  // required float cpuUsageRate = 2;
  bool has_cpuusagerate() const;
  void clear_cpuusagerate();
  static const int kCpuUsageRateFieldNumber = 2;
  float cpuusagerate() const;
  void set_cpuusagerate(float value);

  // required float memoryUsageRate = 3;
  bool has_memoryusagerate() const;
  void clear_memoryusagerate();
  static const int kMemoryUsageRateFieldNumber = 3;
  float memoryusagerate() const;
  void set_memoryusagerate(float value);

  // required float harddiskUsageRate = 4;
  bool has_harddiskusagerate() const;
  void clear_harddiskusagerate();
  static const int kHarddiskUsageRateFieldNumber = 4;
  float harddiskusagerate() const;
  void set_harddiskusagerate(float value);

  // @@protoc_insertion_point(class_scope:CurrentResourceUsage)
 private:
  void set_has_head();
  void clear_has_head();
  void set_has_cpuusagerate();
  void clear_has_cpuusagerate();
  void set_has_memoryusagerate();
  void clear_has_memoryusagerate();
  void set_has_harddiskusagerate();
  void clear_has_harddiskusagerate();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::CommandHead* head_;
  float cpuusagerate_;
  float memoryusagerate_;
  float harddiskusagerate_;
  friend struct  protobuf_monitor_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScadaServiceStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ScadaServiceStatus) */ {
 public:
  ScadaServiceStatus();
  virtual ~ScadaServiceStatus();

  ScadaServiceStatus(const ScadaServiceStatus& from);

  inline ScadaServiceStatus& operator=(const ScadaServiceStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScadaServiceStatus& default_instance();

  static inline const ScadaServiceStatus* internal_default_instance() {
    return reinterpret_cast<const ScadaServiceStatus*>(
               &_ScadaServiceStatus_default_instance_);
  }

  void Swap(ScadaServiceStatus* other);

  // implements Message ----------------------------------------------

  inline ScadaServiceStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ScadaServiceStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScadaServiceStatus& from);
  void MergeFrom(const ScadaServiceStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScadaServiceStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CommandHead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::CommandHead& head() const;
  ::CommandHead* mutable_head();
  ::CommandHead* release_head();
  void set_allocated_head(::CommandHead* head);

  // required .ServiceStatus ScadaServersStatus = 2;
  bool has_scadaserversstatus() const;
  void clear_scadaserversstatus();
  static const int kScadaServersStatusFieldNumber = 2;
  ::ServiceStatus scadaserversstatus() const;
  void set_scadaserversstatus(::ServiceStatus value);

  // required .ServiceStatus CheckTimeServerStatus = 3;
  bool has_checktimeserverstatus() const;
  void clear_checktimeserverstatus();
  static const int kCheckTimeServerStatusFieldNumber = 3;
  ::ServiceStatus checktimeserverstatus() const;
  void set_checktimeserverstatus(::ServiceStatus value);

  // required .ServiceStatus FileDLSvrStatus = 4;
  bool has_filedlsvrstatus() const;
  void clear_filedlsvrstatus();
  static const int kFileDLSvrStatusFieldNumber = 4;
  ::ServiceStatus filedlsvrstatus() const;
  void set_filedlsvrstatus(::ServiceStatus value);

  // required .ServiceStatus FileDLProxyStatus = 5;
  bool has_filedlproxystatus() const;
  void clear_filedlproxystatus();
  static const int kFileDLProxyStatusFieldNumber = 5;
  ::ServiceStatus filedlproxystatus() const;
  void set_filedlproxystatus(::ServiceStatus value);

  // @@protoc_insertion_point(class_scope:ScadaServiceStatus)
 private:
  void set_has_head();
  void clear_has_head();
  void set_has_scadaserversstatus();
  void clear_has_scadaserversstatus();
  void set_has_checktimeserverstatus();
  void clear_has_checktimeserverstatus();
  void set_has_filedlsvrstatus();
  void clear_has_filedlsvrstatus();
  void set_has_filedlproxystatus();
  void clear_has_filedlproxystatus();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::CommandHead* head_;
  int scadaserversstatus_;
  int checktimeserverstatus_;
  int filedlsvrstatus_;
  int filedlproxystatus_;
  friend struct  protobuf_monitor_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScadaVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ScadaVersion) */ {
 public:
  ScadaVersion();
  virtual ~ScadaVersion();

  ScadaVersion(const ScadaVersion& from);

  inline ScadaVersion& operator=(const ScadaVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScadaVersion& default_instance();

  static inline const ScadaVersion* internal_default_instance() {
    return reinterpret_cast<const ScadaVersion*>(
               &_ScadaVersion_default_instance_);
  }

  void Swap(ScadaVersion* other);

  // implements Message ----------------------------------------------

  inline ScadaVersion* New() const PROTOBUF_FINAL { return New(NULL); }

  ScadaVersion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScadaVersion& from);
  void MergeFrom(const ScadaVersion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScadaVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ScadaPlatformVer = 2;
  bool has_scadaplatformver() const;
  void clear_scadaplatformver();
  static const int kScadaPlatformVerFieldNumber = 2;
  const ::std::string& scadaplatformver() const;
  void set_scadaplatformver(const ::std::string& value);
  #if LANG_CXX11
  void set_scadaplatformver(::std::string&& value);
  #endif
  void set_scadaplatformver(const char* value);
  void set_scadaplatformver(const char* value, size_t size);
  ::std::string* mutable_scadaplatformver();
  ::std::string* release_scadaplatformver();
  void set_allocated_scadaplatformver(::std::string* scadaplatformver);

  // required string ScadaAppVer = 3;
  bool has_scadaappver() const;
  void clear_scadaappver();
  static const int kScadaAppVerFieldNumber = 3;
  const ::std::string& scadaappver() const;
  void set_scadaappver(const ::std::string& value);
  #if LANG_CXX11
  void set_scadaappver(::std::string&& value);
  #endif
  void set_scadaappver(const char* value);
  void set_scadaappver(const char* value, size_t size);
  ::std::string* mutable_scadaappver();
  ::std::string* release_scadaappver();
  void set_allocated_scadaappver(::std::string* scadaappver);

  // required string BuildVer = 4;
  bool has_buildver() const;
  void clear_buildver();
  static const int kBuildVerFieldNumber = 4;
  const ::std::string& buildver() const;
  void set_buildver(const ::std::string& value);
  #if LANG_CXX11
  void set_buildver(::std::string&& value);
  #endif
  void set_buildver(const char* value);
  void set_buildver(const char* value, size_t size);
  ::std::string* mutable_buildver();
  ::std::string* release_buildver();
  void set_allocated_buildver(::std::string* buildver);

  // required string DownloadVer = 5;
  bool has_downloadver() const;
  void clear_downloadver();
  static const int kDownloadVerFieldNumber = 5;
  const ::std::string& downloadver() const;
  void set_downloadver(const ::std::string& value);
  #if LANG_CXX11
  void set_downloadver(::std::string&& value);
  #endif
  void set_downloadver(const char* value);
  void set_downloadver(const char* value, size_t size);
  ::std::string* mutable_downloadver();
  ::std::string* release_downloadver();
  void set_allocated_downloadver(::std::string* downloadver);

  // required .CommandHead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::CommandHead& head() const;
  ::CommandHead* mutable_head();
  ::CommandHead* release_head();
  void set_allocated_head(::CommandHead* head);

  // @@protoc_insertion_point(class_scope:ScadaVersion)
 private:
  void set_has_head();
  void clear_has_head();
  void set_has_scadaplatformver();
  void clear_has_scadaplatformver();
  void set_has_scadaappver();
  void clear_has_scadaappver();
  void set_has_buildver();
  void clear_has_buildver();
  void set_has_downloadver();
  void clear_has_downloadver();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr scadaplatformver_;
  ::google::protobuf::internal::ArenaStringPtr scadaappver_;
  ::google::protobuf::internal::ArenaStringPtr buildver_;
  ::google::protobuf::internal::ArenaStringPtr downloadver_;
  ::CommandHead* head_;
  friend struct  protobuf_monitor_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SyncFileInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SyncFileInfo) */ {
 public:
  SyncFileInfo();
  virtual ~SyncFileInfo();

  SyncFileInfo(const SyncFileInfo& from);

  inline SyncFileInfo& operator=(const SyncFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncFileInfo& default_instance();

  static inline const SyncFileInfo* internal_default_instance() {
    return reinterpret_cast<const SyncFileInfo*>(
               &_SyncFileInfo_default_instance_);
  }

  void Swap(SyncFileInfo* other);

  // implements Message ----------------------------------------------

  inline SyncFileInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SyncFileInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SyncFileInfo& from);
  void MergeFrom(const SyncFileInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SyncFileInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string FileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // required string TargetPath = 2;
  bool has_targetpath() const;
  void clear_targetpath();
  static const int kTargetPathFieldNumber = 2;
  const ::std::string& targetpath() const;
  void set_targetpath(const ::std::string& value);
  #if LANG_CXX11
  void set_targetpath(::std::string&& value);
  #endif
  void set_targetpath(const char* value);
  void set_targetpath(const char* value, size_t size);
  ::std::string* mutable_targetpath();
  ::std::string* release_targetpath();
  void set_allocated_targetpath(::std::string* targetpath);

  // @@protoc_insertion_point(class_scope:SyncFileInfo)
 private:
  void set_has_filename();
  void clear_has_filename();
  void set_has_targetpath();
  void clear_has_targetpath();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr targetpath_;
  friend struct  protobuf_monitor_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SyncFileInfoList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SyncFileInfoList) */ {
 public:
  SyncFileInfoList();
  virtual ~SyncFileInfoList();

  SyncFileInfoList(const SyncFileInfoList& from);

  inline SyncFileInfoList& operator=(const SyncFileInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncFileInfoList& default_instance();

  static inline const SyncFileInfoList* internal_default_instance() {
    return reinterpret_cast<const SyncFileInfoList*>(
               &_SyncFileInfoList_default_instance_);
  }

  void Swap(SyncFileInfoList* other);

  // implements Message ----------------------------------------------

  inline SyncFileInfoList* New() const PROTOBUF_FINAL { return New(NULL); }

  SyncFileInfoList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SyncFileInfoList& from);
  void MergeFrom(const SyncFileInfoList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SyncFileInfoList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SyncFileInfo syncList = 2;
  int synclist_size() const;
  void clear_synclist();
  static const int kSyncListFieldNumber = 2;
  const ::SyncFileInfo& synclist(int index) const;
  ::SyncFileInfo* mutable_synclist(int index);
  ::SyncFileInfo* add_synclist();
  ::google::protobuf::RepeatedPtrField< ::SyncFileInfo >*
      mutable_synclist();
  const ::google::protobuf::RepeatedPtrField< ::SyncFileInfo >&
      synclist() const;

  // required .CommandHead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::CommandHead& head() const;
  ::CommandHead* mutable_head();
  ::CommandHead* release_head();
  void set_allocated_head(::CommandHead* head);

  // @@protoc_insertion_point(class_scope:SyncFileInfoList)
 private:
  void set_has_head();
  void clear_has_head();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SyncFileInfo > synclist_;
  ::CommandHead* head_;
  friend struct  protobuf_monitor_5fmessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CommandHead

// required uint32 cmdId = 1;
inline bool CommandHead::has_cmdid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandHead::set_has_cmdid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandHead::clear_has_cmdid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandHead::clear_cmdid() {
  cmdid_ = 0u;
  clear_has_cmdid();
}
inline ::google::protobuf::uint32 CommandHead::cmdid() const {
  // @@protoc_insertion_point(field_get:CommandHead.cmdId)
  return cmdid_;
}
inline void CommandHead::set_cmdid(::google::protobuf::uint32 value) {
  set_has_cmdid();
  cmdid_ = value;
  // @@protoc_insertion_point(field_set:CommandHead.cmdId)
}

// required uint32 cmdLength = 2;
inline bool CommandHead::has_cmdlength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandHead::set_has_cmdlength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandHead::clear_has_cmdlength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandHead::clear_cmdlength() {
  cmdlength_ = 0u;
  clear_has_cmdlength();
}
inline ::google::protobuf::uint32 CommandHead::cmdlength() const {
  // @@protoc_insertion_point(field_get:CommandHead.cmdLength)
  return cmdlength_;
}
inline void CommandHead::set_cmdlength(::google::protobuf::uint32 value) {
  set_has_cmdlength();
  cmdlength_ = value;
  // @@protoc_insertion_point(field_set:CommandHead.cmdLength)
}

// -------------------------------------------------------------------

// DeviceInfo

// required .CommandHead head = 1;
inline bool DeviceInfo::has_head() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceInfo::set_has_head() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceInfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceInfo::clear_head() {
  if (head_ != NULL) head_->::CommandHead::Clear();
  clear_has_head();
}
inline const ::CommandHead& DeviceInfo::head() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.head)
  return head_ != NULL ? *head_
                         : *::CommandHead::internal_default_instance();
}
inline ::CommandHead* DeviceInfo::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::CommandHead;
  }
  // @@protoc_insertion_point(field_mutable:DeviceInfo.head)
  return head_;
}
inline ::CommandHead* DeviceInfo::release_head() {
  // @@protoc_insertion_point(field_release:DeviceInfo.head)
  clear_has_head();
  ::CommandHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void DeviceInfo::set_allocated_head(::CommandHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.head)
}

// required string hostName = 2;
inline bool DeviceInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceInfo::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& DeviceInfo::hostname() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.hostName)
  return hostname_.GetNoArena();
}
inline void DeviceInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeviceInfo.hostName)
}
#if LANG_CXX11
inline void DeviceInfo::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DeviceInfo.hostName)
}
#endif
inline void DeviceInfo::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeviceInfo.hostName)
}
inline void DeviceInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeviceInfo.hostName)
}
inline ::std::string* DeviceInfo::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.hostName)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:DeviceInfo.hostName)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.hostName)
}

// required string system = 3;
inline bool DeviceInfo::has_system() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceInfo::set_has_system() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceInfo::clear_has_system() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceInfo::clear_system() {
  system_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_system();
}
inline const ::std::string& DeviceInfo::system() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.system)
  return system_.GetNoArena();
}
inline void DeviceInfo::set_system(const ::std::string& value) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeviceInfo.system)
}
#if LANG_CXX11
inline void DeviceInfo::set_system(::std::string&& value) {
  set_has_system();
  system_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DeviceInfo.system)
}
#endif
inline void DeviceInfo::set_system(const char* value) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeviceInfo.system)
}
inline void DeviceInfo::set_system(const char* value, size_t size) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeviceInfo.system)
}
inline ::std::string* DeviceInfo::mutable_system() {
  set_has_system();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.system)
  return system_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_system() {
  // @@protoc_insertion_point(field_release:DeviceInfo.system)
  clear_has_system();
  return system_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_system(::std::string* system) {
  if (system != NULL) {
    set_has_system();
  } else {
    clear_has_system();
  }
  system_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system);
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.system)
}

// required string hardware = 4;
inline bool DeviceInfo::has_hardware() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceInfo::set_has_hardware() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceInfo::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceInfo::clear_hardware() {
  hardware_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware();
}
inline const ::std::string& DeviceInfo::hardware() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.hardware)
  return hardware_.GetNoArena();
}
inline void DeviceInfo::set_hardware(const ::std::string& value) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeviceInfo.hardware)
}
#if LANG_CXX11
inline void DeviceInfo::set_hardware(::std::string&& value) {
  set_has_hardware();
  hardware_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DeviceInfo.hardware)
}
#endif
inline void DeviceInfo::set_hardware(const char* value) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeviceInfo.hardware)
}
inline void DeviceInfo::set_hardware(const char* value, size_t size) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeviceInfo.hardware)
}
inline ::std::string* DeviceInfo::mutable_hardware() {
  set_has_hardware();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.hardware)
  return hardware_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_hardware() {
  // @@protoc_insertion_point(field_release:DeviceInfo.hardware)
  clear_has_hardware();
  return hardware_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_hardware(::std::string* hardware) {
  if (hardware != NULL) {
    set_has_hardware();
  } else {
    clear_has_hardware();
  }
  hardware_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware);
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.hardware)
}

// required string nodeName = 5;
inline bool DeviceInfo::has_nodename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceInfo::set_has_nodename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceInfo::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceInfo::clear_nodename() {
  nodename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodename();
}
inline const ::std::string& DeviceInfo::nodename() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.nodeName)
  return nodename_.GetNoArena();
}
inline void DeviceInfo::set_nodename(const ::std::string& value) {
  set_has_nodename();
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeviceInfo.nodeName)
}
#if LANG_CXX11
inline void DeviceInfo::set_nodename(::std::string&& value) {
  set_has_nodename();
  nodename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DeviceInfo.nodeName)
}
#endif
inline void DeviceInfo::set_nodename(const char* value) {
  set_has_nodename();
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeviceInfo.nodeName)
}
inline void DeviceInfo::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeviceInfo.nodeName)
}
inline ::std::string* DeviceInfo::mutable_nodename() {
  set_has_nodename();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.nodeName)
  return nodename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_nodename() {
  // @@protoc_insertion_point(field_release:DeviceInfo.nodeName)
  clear_has_nodename();
  return nodename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_nodename(::std::string* nodename) {
  if (nodename != NULL) {
    set_has_nodename();
  } else {
    clear_has_nodename();
  }
  nodename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodename);
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.nodeName)
}

// required string version = 6;
inline bool DeviceInfo::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceInfo::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& DeviceInfo::version() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.version)
  return version_.GetNoArena();
}
inline void DeviceInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeviceInfo.version)
}
#if LANG_CXX11
inline void DeviceInfo::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DeviceInfo.version)
}
#endif
inline void DeviceInfo::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeviceInfo.version)
}
inline void DeviceInfo::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeviceInfo.version)
}
inline ::std::string* DeviceInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_version() {
  // @@protoc_insertion_point(field_release:DeviceInfo.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.version)
}

// required string memorySize = 7;
inline bool DeviceInfo::has_memorysize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceInfo::set_has_memorysize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceInfo::clear_has_memorysize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceInfo::clear_memorysize() {
  memorysize_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memorysize();
}
inline const ::std::string& DeviceInfo::memorysize() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.memorySize)
  return memorysize_.GetNoArena();
}
inline void DeviceInfo::set_memorysize(const ::std::string& value) {
  set_has_memorysize();
  memorysize_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeviceInfo.memorySize)
}
#if LANG_CXX11
inline void DeviceInfo::set_memorysize(::std::string&& value) {
  set_has_memorysize();
  memorysize_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DeviceInfo.memorySize)
}
#endif
inline void DeviceInfo::set_memorysize(const char* value) {
  set_has_memorysize();
  memorysize_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeviceInfo.memorySize)
}
inline void DeviceInfo::set_memorysize(const char* value, size_t size) {
  set_has_memorysize();
  memorysize_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeviceInfo.memorySize)
}
inline ::std::string* DeviceInfo::mutable_memorysize() {
  set_has_memorysize();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.memorySize)
  return memorysize_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_memorysize() {
  // @@protoc_insertion_point(field_release:DeviceInfo.memorySize)
  clear_has_memorysize();
  return memorysize_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_memorysize(::std::string* memorysize) {
  if (memorysize != NULL) {
    set_has_memorysize();
  } else {
    clear_has_memorysize();
  }
  memorysize_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memorysize);
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.memorySize)
}

// required string harddiskSize = 8;
inline bool DeviceInfo::has_harddisksize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceInfo::set_has_harddisksize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceInfo::clear_has_harddisksize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceInfo::clear_harddisksize() {
  harddisksize_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_harddisksize();
}
inline const ::std::string& DeviceInfo::harddisksize() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.harddiskSize)
  return harddisksize_.GetNoArena();
}
inline void DeviceInfo::set_harddisksize(const ::std::string& value) {
  set_has_harddisksize();
  harddisksize_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeviceInfo.harddiskSize)
}
#if LANG_CXX11
inline void DeviceInfo::set_harddisksize(::std::string&& value) {
  set_has_harddisksize();
  harddisksize_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DeviceInfo.harddiskSize)
}
#endif
inline void DeviceInfo::set_harddisksize(const char* value) {
  set_has_harddisksize();
  harddisksize_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeviceInfo.harddiskSize)
}
inline void DeviceInfo::set_harddisksize(const char* value, size_t size) {
  set_has_harddisksize();
  harddisksize_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeviceInfo.harddiskSize)
}
inline ::std::string* DeviceInfo::mutable_harddisksize() {
  set_has_harddisksize();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.harddiskSize)
  return harddisksize_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_harddisksize() {
  // @@protoc_insertion_point(field_release:DeviceInfo.harddiskSize)
  clear_has_harddisksize();
  return harddisksize_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_harddisksize(::std::string* harddisksize) {
  if (harddisksize != NULL) {
    set_has_harddisksize();
  } else {
    clear_has_harddisksize();
  }
  harddisksize_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), harddisksize);
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.harddiskSize)
}

// -------------------------------------------------------------------

// CurrentResourceUsage

// required .CommandHead head = 1;
inline bool CurrentResourceUsage::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrentResourceUsage::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrentResourceUsage::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrentResourceUsage::clear_head() {
  if (head_ != NULL) head_->::CommandHead::Clear();
  clear_has_head();
}
inline const ::CommandHead& CurrentResourceUsage::head() const {
  // @@protoc_insertion_point(field_get:CurrentResourceUsage.head)
  return head_ != NULL ? *head_
                         : *::CommandHead::internal_default_instance();
}
inline ::CommandHead* CurrentResourceUsage::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::CommandHead;
  }
  // @@protoc_insertion_point(field_mutable:CurrentResourceUsage.head)
  return head_;
}
inline ::CommandHead* CurrentResourceUsage::release_head() {
  // @@protoc_insertion_point(field_release:CurrentResourceUsage.head)
  clear_has_head();
  ::CommandHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void CurrentResourceUsage::set_allocated_head(::CommandHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:CurrentResourceUsage.head)
}

// required float cpuUsageRate = 2;
inline bool CurrentResourceUsage::has_cpuusagerate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrentResourceUsage::set_has_cpuusagerate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrentResourceUsage::clear_has_cpuusagerate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrentResourceUsage::clear_cpuusagerate() {
  cpuusagerate_ = 0;
  clear_has_cpuusagerate();
}
inline float CurrentResourceUsage::cpuusagerate() const {
  // @@protoc_insertion_point(field_get:CurrentResourceUsage.cpuUsageRate)
  return cpuusagerate_;
}
inline void CurrentResourceUsage::set_cpuusagerate(float value) {
  set_has_cpuusagerate();
  cpuusagerate_ = value;
  // @@protoc_insertion_point(field_set:CurrentResourceUsage.cpuUsageRate)
}

// required float memoryUsageRate = 3;
inline bool CurrentResourceUsage::has_memoryusagerate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CurrentResourceUsage::set_has_memoryusagerate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CurrentResourceUsage::clear_has_memoryusagerate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CurrentResourceUsage::clear_memoryusagerate() {
  memoryusagerate_ = 0;
  clear_has_memoryusagerate();
}
inline float CurrentResourceUsage::memoryusagerate() const {
  // @@protoc_insertion_point(field_get:CurrentResourceUsage.memoryUsageRate)
  return memoryusagerate_;
}
inline void CurrentResourceUsage::set_memoryusagerate(float value) {
  set_has_memoryusagerate();
  memoryusagerate_ = value;
  // @@protoc_insertion_point(field_set:CurrentResourceUsage.memoryUsageRate)
}

// required float harddiskUsageRate = 4;
inline bool CurrentResourceUsage::has_harddiskusagerate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CurrentResourceUsage::set_has_harddiskusagerate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CurrentResourceUsage::clear_has_harddiskusagerate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CurrentResourceUsage::clear_harddiskusagerate() {
  harddiskusagerate_ = 0;
  clear_has_harddiskusagerate();
}
inline float CurrentResourceUsage::harddiskusagerate() const {
  // @@protoc_insertion_point(field_get:CurrentResourceUsage.harddiskUsageRate)
  return harddiskusagerate_;
}
inline void CurrentResourceUsage::set_harddiskusagerate(float value) {
  set_has_harddiskusagerate();
  harddiskusagerate_ = value;
  // @@protoc_insertion_point(field_set:CurrentResourceUsage.harddiskUsageRate)
}

// -------------------------------------------------------------------

// ScadaServiceStatus

// required .CommandHead head = 1;
inline bool ScadaServiceStatus::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScadaServiceStatus::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScadaServiceStatus::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScadaServiceStatus::clear_head() {
  if (head_ != NULL) head_->::CommandHead::Clear();
  clear_has_head();
}
inline const ::CommandHead& ScadaServiceStatus::head() const {
  // @@protoc_insertion_point(field_get:ScadaServiceStatus.head)
  return head_ != NULL ? *head_
                         : *::CommandHead::internal_default_instance();
}
inline ::CommandHead* ScadaServiceStatus::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::CommandHead;
  }
  // @@protoc_insertion_point(field_mutable:ScadaServiceStatus.head)
  return head_;
}
inline ::CommandHead* ScadaServiceStatus::release_head() {
  // @@protoc_insertion_point(field_release:ScadaServiceStatus.head)
  clear_has_head();
  ::CommandHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void ScadaServiceStatus::set_allocated_head(::CommandHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:ScadaServiceStatus.head)
}

// required .ServiceStatus ScadaServersStatus = 2;
inline bool ScadaServiceStatus::has_scadaserversstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScadaServiceStatus::set_has_scadaserversstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScadaServiceStatus::clear_has_scadaserversstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScadaServiceStatus::clear_scadaserversstatus() {
  scadaserversstatus_ = 0;
  clear_has_scadaserversstatus();
}
inline ::ServiceStatus ScadaServiceStatus::scadaserversstatus() const {
  // @@protoc_insertion_point(field_get:ScadaServiceStatus.ScadaServersStatus)
  return static_cast< ::ServiceStatus >(scadaserversstatus_);
}
inline void ScadaServiceStatus::set_scadaserversstatus(::ServiceStatus value) {
  assert(::ServiceStatus_IsValid(value));
  set_has_scadaserversstatus();
  scadaserversstatus_ = value;
  // @@protoc_insertion_point(field_set:ScadaServiceStatus.ScadaServersStatus)
}

// required .ServiceStatus CheckTimeServerStatus = 3;
inline bool ScadaServiceStatus::has_checktimeserverstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScadaServiceStatus::set_has_checktimeserverstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScadaServiceStatus::clear_has_checktimeserverstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScadaServiceStatus::clear_checktimeserverstatus() {
  checktimeserverstatus_ = 0;
  clear_has_checktimeserverstatus();
}
inline ::ServiceStatus ScadaServiceStatus::checktimeserverstatus() const {
  // @@protoc_insertion_point(field_get:ScadaServiceStatus.CheckTimeServerStatus)
  return static_cast< ::ServiceStatus >(checktimeserverstatus_);
}
inline void ScadaServiceStatus::set_checktimeserverstatus(::ServiceStatus value) {
  assert(::ServiceStatus_IsValid(value));
  set_has_checktimeserverstatus();
  checktimeserverstatus_ = value;
  // @@protoc_insertion_point(field_set:ScadaServiceStatus.CheckTimeServerStatus)
}

// required .ServiceStatus FileDLSvrStatus = 4;
inline bool ScadaServiceStatus::has_filedlsvrstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScadaServiceStatus::set_has_filedlsvrstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScadaServiceStatus::clear_has_filedlsvrstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScadaServiceStatus::clear_filedlsvrstatus() {
  filedlsvrstatus_ = 0;
  clear_has_filedlsvrstatus();
}
inline ::ServiceStatus ScadaServiceStatus::filedlsvrstatus() const {
  // @@protoc_insertion_point(field_get:ScadaServiceStatus.FileDLSvrStatus)
  return static_cast< ::ServiceStatus >(filedlsvrstatus_);
}
inline void ScadaServiceStatus::set_filedlsvrstatus(::ServiceStatus value) {
  assert(::ServiceStatus_IsValid(value));
  set_has_filedlsvrstatus();
  filedlsvrstatus_ = value;
  // @@protoc_insertion_point(field_set:ScadaServiceStatus.FileDLSvrStatus)
}

// required .ServiceStatus FileDLProxyStatus = 5;
inline bool ScadaServiceStatus::has_filedlproxystatus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScadaServiceStatus::set_has_filedlproxystatus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScadaServiceStatus::clear_has_filedlproxystatus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScadaServiceStatus::clear_filedlproxystatus() {
  filedlproxystatus_ = 0;
  clear_has_filedlproxystatus();
}
inline ::ServiceStatus ScadaServiceStatus::filedlproxystatus() const {
  // @@protoc_insertion_point(field_get:ScadaServiceStatus.FileDLProxyStatus)
  return static_cast< ::ServiceStatus >(filedlproxystatus_);
}
inline void ScadaServiceStatus::set_filedlproxystatus(::ServiceStatus value) {
  assert(::ServiceStatus_IsValid(value));
  set_has_filedlproxystatus();
  filedlproxystatus_ = value;
  // @@protoc_insertion_point(field_set:ScadaServiceStatus.FileDLProxyStatus)
}

// -------------------------------------------------------------------

// ScadaVersion

// required .CommandHead head = 1;
inline bool ScadaVersion::has_head() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScadaVersion::set_has_head() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScadaVersion::clear_has_head() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScadaVersion::clear_head() {
  if (head_ != NULL) head_->::CommandHead::Clear();
  clear_has_head();
}
inline const ::CommandHead& ScadaVersion::head() const {
  // @@protoc_insertion_point(field_get:ScadaVersion.head)
  return head_ != NULL ? *head_
                         : *::CommandHead::internal_default_instance();
}
inline ::CommandHead* ScadaVersion::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::CommandHead;
  }
  // @@protoc_insertion_point(field_mutable:ScadaVersion.head)
  return head_;
}
inline ::CommandHead* ScadaVersion::release_head() {
  // @@protoc_insertion_point(field_release:ScadaVersion.head)
  clear_has_head();
  ::CommandHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void ScadaVersion::set_allocated_head(::CommandHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:ScadaVersion.head)
}

// required string ScadaPlatformVer = 2;
inline bool ScadaVersion::has_scadaplatformver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScadaVersion::set_has_scadaplatformver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScadaVersion::clear_has_scadaplatformver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScadaVersion::clear_scadaplatformver() {
  scadaplatformver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scadaplatformver();
}
inline const ::std::string& ScadaVersion::scadaplatformver() const {
  // @@protoc_insertion_point(field_get:ScadaVersion.ScadaPlatformVer)
  return scadaplatformver_.GetNoArena();
}
inline void ScadaVersion::set_scadaplatformver(const ::std::string& value) {
  set_has_scadaplatformver();
  scadaplatformver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ScadaVersion.ScadaPlatformVer)
}
#if LANG_CXX11
inline void ScadaVersion::set_scadaplatformver(::std::string&& value) {
  set_has_scadaplatformver();
  scadaplatformver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ScadaVersion.ScadaPlatformVer)
}
#endif
inline void ScadaVersion::set_scadaplatformver(const char* value) {
  set_has_scadaplatformver();
  scadaplatformver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ScadaVersion.ScadaPlatformVer)
}
inline void ScadaVersion::set_scadaplatformver(const char* value, size_t size) {
  set_has_scadaplatformver();
  scadaplatformver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ScadaVersion.ScadaPlatformVer)
}
inline ::std::string* ScadaVersion::mutable_scadaplatformver() {
  set_has_scadaplatformver();
  // @@protoc_insertion_point(field_mutable:ScadaVersion.ScadaPlatformVer)
  return scadaplatformver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScadaVersion::release_scadaplatformver() {
  // @@protoc_insertion_point(field_release:ScadaVersion.ScadaPlatformVer)
  clear_has_scadaplatformver();
  return scadaplatformver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScadaVersion::set_allocated_scadaplatformver(::std::string* scadaplatformver) {
  if (scadaplatformver != NULL) {
    set_has_scadaplatformver();
  } else {
    clear_has_scadaplatformver();
  }
  scadaplatformver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scadaplatformver);
  // @@protoc_insertion_point(field_set_allocated:ScadaVersion.ScadaPlatformVer)
}

// required string ScadaAppVer = 3;
inline bool ScadaVersion::has_scadaappver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScadaVersion::set_has_scadaappver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScadaVersion::clear_has_scadaappver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScadaVersion::clear_scadaappver() {
  scadaappver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scadaappver();
}
inline const ::std::string& ScadaVersion::scadaappver() const {
  // @@protoc_insertion_point(field_get:ScadaVersion.ScadaAppVer)
  return scadaappver_.GetNoArena();
}
inline void ScadaVersion::set_scadaappver(const ::std::string& value) {
  set_has_scadaappver();
  scadaappver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ScadaVersion.ScadaAppVer)
}
#if LANG_CXX11
inline void ScadaVersion::set_scadaappver(::std::string&& value) {
  set_has_scadaappver();
  scadaappver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ScadaVersion.ScadaAppVer)
}
#endif
inline void ScadaVersion::set_scadaappver(const char* value) {
  set_has_scadaappver();
  scadaappver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ScadaVersion.ScadaAppVer)
}
inline void ScadaVersion::set_scadaappver(const char* value, size_t size) {
  set_has_scadaappver();
  scadaappver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ScadaVersion.ScadaAppVer)
}
inline ::std::string* ScadaVersion::mutable_scadaappver() {
  set_has_scadaappver();
  // @@protoc_insertion_point(field_mutable:ScadaVersion.ScadaAppVer)
  return scadaappver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScadaVersion::release_scadaappver() {
  // @@protoc_insertion_point(field_release:ScadaVersion.ScadaAppVer)
  clear_has_scadaappver();
  return scadaappver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScadaVersion::set_allocated_scadaappver(::std::string* scadaappver) {
  if (scadaappver != NULL) {
    set_has_scadaappver();
  } else {
    clear_has_scadaappver();
  }
  scadaappver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scadaappver);
  // @@protoc_insertion_point(field_set_allocated:ScadaVersion.ScadaAppVer)
}

// required string BuildVer = 4;
inline bool ScadaVersion::has_buildver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScadaVersion::set_has_buildver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScadaVersion::clear_has_buildver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScadaVersion::clear_buildver() {
  buildver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buildver();
}
inline const ::std::string& ScadaVersion::buildver() const {
  // @@protoc_insertion_point(field_get:ScadaVersion.BuildVer)
  return buildver_.GetNoArena();
}
inline void ScadaVersion::set_buildver(const ::std::string& value) {
  set_has_buildver();
  buildver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ScadaVersion.BuildVer)
}
#if LANG_CXX11
inline void ScadaVersion::set_buildver(::std::string&& value) {
  set_has_buildver();
  buildver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ScadaVersion.BuildVer)
}
#endif
inline void ScadaVersion::set_buildver(const char* value) {
  set_has_buildver();
  buildver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ScadaVersion.BuildVer)
}
inline void ScadaVersion::set_buildver(const char* value, size_t size) {
  set_has_buildver();
  buildver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ScadaVersion.BuildVer)
}
inline ::std::string* ScadaVersion::mutable_buildver() {
  set_has_buildver();
  // @@protoc_insertion_point(field_mutable:ScadaVersion.BuildVer)
  return buildver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScadaVersion::release_buildver() {
  // @@protoc_insertion_point(field_release:ScadaVersion.BuildVer)
  clear_has_buildver();
  return buildver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScadaVersion::set_allocated_buildver(::std::string* buildver) {
  if (buildver != NULL) {
    set_has_buildver();
  } else {
    clear_has_buildver();
  }
  buildver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buildver);
  // @@protoc_insertion_point(field_set_allocated:ScadaVersion.BuildVer)
}

// required string DownloadVer = 5;
inline bool ScadaVersion::has_downloadver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScadaVersion::set_has_downloadver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScadaVersion::clear_has_downloadver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScadaVersion::clear_downloadver() {
  downloadver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_downloadver();
}
inline const ::std::string& ScadaVersion::downloadver() const {
  // @@protoc_insertion_point(field_get:ScadaVersion.DownloadVer)
  return downloadver_.GetNoArena();
}
inline void ScadaVersion::set_downloadver(const ::std::string& value) {
  set_has_downloadver();
  downloadver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ScadaVersion.DownloadVer)
}
#if LANG_CXX11
inline void ScadaVersion::set_downloadver(::std::string&& value) {
  set_has_downloadver();
  downloadver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ScadaVersion.DownloadVer)
}
#endif
inline void ScadaVersion::set_downloadver(const char* value) {
  set_has_downloadver();
  downloadver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ScadaVersion.DownloadVer)
}
inline void ScadaVersion::set_downloadver(const char* value, size_t size) {
  set_has_downloadver();
  downloadver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ScadaVersion.DownloadVer)
}
inline ::std::string* ScadaVersion::mutable_downloadver() {
  set_has_downloadver();
  // @@protoc_insertion_point(field_mutable:ScadaVersion.DownloadVer)
  return downloadver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScadaVersion::release_downloadver() {
  // @@protoc_insertion_point(field_release:ScadaVersion.DownloadVer)
  clear_has_downloadver();
  return downloadver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScadaVersion::set_allocated_downloadver(::std::string* downloadver) {
  if (downloadver != NULL) {
    set_has_downloadver();
  } else {
    clear_has_downloadver();
  }
  downloadver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), downloadver);
  // @@protoc_insertion_point(field_set_allocated:ScadaVersion.DownloadVer)
}

// -------------------------------------------------------------------

// SyncFileInfo

// required string FileName = 1;
inline bool SyncFileInfo::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncFileInfo::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncFileInfo::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncFileInfo::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& SyncFileInfo::filename() const {
  // @@protoc_insertion_point(field_get:SyncFileInfo.FileName)
  return filename_.GetNoArena();
}
inline void SyncFileInfo::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SyncFileInfo.FileName)
}
#if LANG_CXX11
inline void SyncFileInfo::set_filename(::std::string&& value) {
  set_has_filename();
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SyncFileInfo.FileName)
}
#endif
inline void SyncFileInfo::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SyncFileInfo.FileName)
}
inline void SyncFileInfo::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SyncFileInfo.FileName)
}
inline ::std::string* SyncFileInfo::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:SyncFileInfo.FileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SyncFileInfo::release_filename() {
  // @@protoc_insertion_point(field_release:SyncFileInfo.FileName)
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SyncFileInfo::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:SyncFileInfo.FileName)
}

// required string TargetPath = 2;
inline bool SyncFileInfo::has_targetpath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncFileInfo::set_has_targetpath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncFileInfo::clear_has_targetpath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncFileInfo::clear_targetpath() {
  targetpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_targetpath();
}
inline const ::std::string& SyncFileInfo::targetpath() const {
  // @@protoc_insertion_point(field_get:SyncFileInfo.TargetPath)
  return targetpath_.GetNoArena();
}
inline void SyncFileInfo::set_targetpath(const ::std::string& value) {
  set_has_targetpath();
  targetpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SyncFileInfo.TargetPath)
}
#if LANG_CXX11
inline void SyncFileInfo::set_targetpath(::std::string&& value) {
  set_has_targetpath();
  targetpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SyncFileInfo.TargetPath)
}
#endif
inline void SyncFileInfo::set_targetpath(const char* value) {
  set_has_targetpath();
  targetpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SyncFileInfo.TargetPath)
}
inline void SyncFileInfo::set_targetpath(const char* value, size_t size) {
  set_has_targetpath();
  targetpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SyncFileInfo.TargetPath)
}
inline ::std::string* SyncFileInfo::mutable_targetpath() {
  set_has_targetpath();
  // @@protoc_insertion_point(field_mutable:SyncFileInfo.TargetPath)
  return targetpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SyncFileInfo::release_targetpath() {
  // @@protoc_insertion_point(field_release:SyncFileInfo.TargetPath)
  clear_has_targetpath();
  return targetpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SyncFileInfo::set_allocated_targetpath(::std::string* targetpath) {
  if (targetpath != NULL) {
    set_has_targetpath();
  } else {
    clear_has_targetpath();
  }
  targetpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetpath);
  // @@protoc_insertion_point(field_set_allocated:SyncFileInfo.TargetPath)
}

// -------------------------------------------------------------------

// SyncFileInfoList

// required .CommandHead head = 1;
inline bool SyncFileInfoList::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncFileInfoList::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncFileInfoList::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncFileInfoList::clear_head() {
  if (head_ != NULL) head_->::CommandHead::Clear();
  clear_has_head();
}
inline const ::CommandHead& SyncFileInfoList::head() const {
  // @@protoc_insertion_point(field_get:SyncFileInfoList.head)
  return head_ != NULL ? *head_
                         : *::CommandHead::internal_default_instance();
}
inline ::CommandHead* SyncFileInfoList::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::CommandHead;
  }
  // @@protoc_insertion_point(field_mutable:SyncFileInfoList.head)
  return head_;
}
inline ::CommandHead* SyncFileInfoList::release_head() {
  // @@protoc_insertion_point(field_release:SyncFileInfoList.head)
  clear_has_head();
  ::CommandHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void SyncFileInfoList::set_allocated_head(::CommandHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:SyncFileInfoList.head)
}

// repeated .SyncFileInfo syncList = 2;
inline int SyncFileInfoList::synclist_size() const {
  return synclist_.size();
}
inline void SyncFileInfoList::clear_synclist() {
  synclist_.Clear();
}
inline const ::SyncFileInfo& SyncFileInfoList::synclist(int index) const {
  // @@protoc_insertion_point(field_get:SyncFileInfoList.syncList)
  return synclist_.Get(index);
}
inline ::SyncFileInfo* SyncFileInfoList::mutable_synclist(int index) {
  // @@protoc_insertion_point(field_mutable:SyncFileInfoList.syncList)
  return synclist_.Mutable(index);
}
inline ::SyncFileInfo* SyncFileInfoList::add_synclist() {
  // @@protoc_insertion_point(field_add:SyncFileInfoList.syncList)
  return synclist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SyncFileInfo >*
SyncFileInfoList::mutable_synclist() {
  // @@protoc_insertion_point(field_mutable_list:SyncFileInfoList.syncList)
  return &synclist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SyncFileInfo >&
SyncFileInfoList::synclist() const {
  // @@protoc_insertion_point(field_list:SyncFileInfoList.syncList)
  return synclist_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ServiceStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServiceStatus>() {
  return ::ServiceStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_monitor_5fmessage_2eproto__INCLUDED
